import EventEmitter from 'events';
import path from 'path';
import module$1 from 'module';
import { readFileSync, realpathSync, watch } from 'fs';
import * as fs from 'fs';

var modules = {};

var getModule = function(dir) {
  var rootPath = dir ? path.resolve(dir) : process.cwd();
  var rootName = path.join(rootPath, '@root');
  var root = modules[rootName];
  if (!root) {
    root = new module$1(rootName);
    root.filename = rootName;
    root.paths = module$1._nodeModulePaths(rootPath);
    modules[rootName] = root;
  }
  return root;
};

var requireRelative = function(requested, relativeTo) {
  var root = getModule(relativeTo);
  return root.require(requested);
};

requireRelative.resolve = function(requested, relativeTo) {
  var root = getModule(relativeTo);
  return module$1._resolveFilename(requested, root);
};

var index$1 = requireRelative;

function sequence ( array, fn ) {
	let results = [];
	let promise = Promise.resolve();

	function next ( member, i ) {
		return fn( member ).then( value => results[i] = value );
	}

	for ( let i = 0; i < array.length; i += 1 ) {
		promise = promise.then( () => next( array[i], i ) );
	}

	return promise.then( () => results );
}

const opts = { encoding: 'utf-8', persistent: true };

let chokidar;

try {
	chokidar = index$1( 'chokidar', process.cwd() );
} catch (err) {
	chokidar = null;
}

class FileWatcher {
	constructor ( file, data, callback, useChokidar, dispose ) {
		const handleWatchEvent = (event) => {
			if ( event === 'rename' || event === 'unlink' ) {
				this.fsWatcher.close();
				dispose();
				callback();
			} else {
				// this is necessary because we get duplicate events...
				const contents = readFileSync( file, 'utf-8' );
				if ( contents !== data ) {
					data = contents;
					callback();
				}
			}
		};

		try {
			if (useChokidar)
				{ this.fsWatcher = chokidar.watch(file, { ignoreInitial: true }).on('all', handleWatchEvent); }
			else
				{ this.fsWatcher = watch( file, opts, handleWatchEvent); }

			this.fileExists = true;
		} catch ( err ) {
			if ( err.code === 'ENOENT' ) {
				// can't watch files that don't exist (e.g. injected
				// by plugins somehow)
				this.fileExists = false;
			} else {
				throw err;
			}
		}
	}

	close () {
		this.fsWatcher.close();
	}
}

function watch$1 ( rollup, options ) {
	const watchOptions = options.watch || {};
	const useChokidar = 'useChokidar' in watchOptions ? watchOptions.useChokidar : !!chokidar;

	if ( useChokidar && !chokidar ) {
		throw new Error( `options.watch.useChokidar is true, but chokidar could not be found. Have you installed it?` );
	}

	const watcher = new EventEmitter();

	const dests = options.dest ? [ path.resolve( options.dest ) ] : options.targets.map( target => path.resolve( target.dest ) );
	let filewatchers = new Map();

	let rebuildScheduled = false;
	let building = false;
	let watching = false;
	let closed = false;

	let timeout;
	let cache;

	function triggerRebuild () {
		clearTimeout( timeout );
		rebuildScheduled = true;

		timeout = setTimeout( () => {
			if ( !building ) { build(); }
		}, 50 );
	}

	function addFileWatchersForModules ( modules ) {
		modules.forEach( module => {
			let id = module.id;

			// skip plugin helper modules
			if ( /\0/.test( id ) ) { return; }

			try {
				id = realpathSync( id );
			} catch ( err ) {
				return;
			}

			if ( ~dests.indexOf( id ) ) {
				throw new Error( 'Cannot import the generated bundle' );
			}

			if ( !filewatchers.has( id ) ) {
				const watcher = new FileWatcher( id, module.originalCode, triggerRebuild, useChokidar, () => {
					filewatchers.delete( id );
				});

				if ( watcher.fileExists ) { filewatchers.set( id, watcher ); }
			}
		});
	}

	function build () {
		if ( building || closed ) { return; }

		rebuildScheduled = false;

		let start = Date.now();
		let initial = !watching;
		if ( cache ) { options.cache = cache; }

		watcher.emit( 'event', { code: 'BUILD_START' });

		building = true;

		return rollup.rollup( options )
			.then( bundle => {
				// Save off bundle for re-use later
				cache = bundle;

				if ( !closed ) {
					addFileWatchersForModules(bundle.modules);
				}

				// Now we're watching
				watching = true;

				if ( options.targets ) {
					return sequence( options.targets, target => {
						const mergedOptions = Object.assign( {}, options, target );
						return bundle.write( mergedOptions );
					});
				}

				return bundle.write( options );
			})
			.then( () => {
				watcher.emit( 'event', {
					code: 'BUILD_END',
					duration: Date.now() - start,
					initial
				});
			}, error => {
				try {
					//If build failed, make sure we are still watching those files from the most recent successful build.
					addFileWatchersForModules( cache.modules );
				}
				catch (e) {
					//Ignore if they tried to import the output. We are already inside of a catch (probably caused by that).
				}
				watcher.emit( 'event', {
					code: 'ERROR',
					error
				});
			})
			.then( () => {
				building = false;
				if ( rebuildScheduled && !closed ) { build(); }
			});
	}

	// build on next tick, so consumers can listen for BUILD_START
	process.nextTick( build );

	watcher.close = () => {
		for ( const fw of filewatchers.values() ) {
			fw.close();
		}
		closed = true;
	};

	return watcher;
}

export default watch$1;
